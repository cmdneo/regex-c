#ifndef INCLUDE_REGEX_PARSER_H_INTERNAL
#define INCLUDE_REGEX_PARSER_H_INTERNAL

#include "strlx/strlx.h"

#include "dsa.h"

/* -- Data structures -- */

typedef struct egraph_T egraph_T;

/**
 * @brief Execution graph DS
 */
struct egraph_T {
	int error;
	int min;
	int max;
	int value;
	int nmatches;
	unsigned dead : 1;
	unsigned lazy : 1;
	unsigned capture : 1;
	unsigned atomic : 1;
	unsigned anyone : 1;
	unsigned anychar : 1;
	int nnodes;
	int nodecap;
	egraph_T *nodes;
	egraph_T *prev;
};

typedef struct token_T {
	int pos;
	int value;
	int type;
	str chars;
} token_T;

typedef struct pstate_T {
	int error;
	int ntokens;
	int ctx;
	int at; /** tracker */
	egraph_T *exec_graph;
	pairs_T *parens;
	token_T *tokens;
	strbuf const *pattern;
} pstate_T;

typedef struct regex {
	strbuf const *pattern;
	egraph_T *exec_graph;
} regex;

/*  -- Functions -- */

#define EGDATA_SIZE(n) (sizeof(egdata_T) + sizeof(egraph_T[(n)]))
#define TOKEN_NEW(typ, val) ((token_T){ .type = typ, .value = val })
egraph_T *re_parse(strbuf const *pattern);

/* -- Config & Data -- */

#define EMPTY_NODE ((egraph_T){ 0 })
static const str RE_CTX_CHARS = M_str("b");

enum re_ctx {
	RE_CTX_NONE = 0,
	RE_CTX_BKT,
};

enum re_token_type {
	/* Must be larger than RE_NTOKENS */
	RE_TT_GNUM = 200,
	RE_TT_ORD,
};

/*
 * Token type arranged in tokens having:
 * Highest priority -> Lowest Priority,
 * Most chars -------> Least characters
 *
 * Ordinary single char tokens have least priority, and not listed
 */
enum re_token_code {
	/* Context based tokens */
	RE_TC_CTX_B,

	/* '\['. As \[:<pcc>:] should not be parsed as a PCC */
	RE_TC_ESC_LBRACKET,

	/* Posix character class tokens */
	RE_TC_PCC_ALNUM,
	RE_TC_PCC_ALPHA,
	RE_TC_PCC_ASCII,
	RE_TC_PCC_BLANK,
	RE_TC_PCC_CNTRL,
	RE_TC_PCC_DIGIT,
	RE_TC_PCC_GRAPH,
	RE_TC_PCC_LOWER,
	RE_TC_PCC_PRINT,
	RE_TC_PCC_PUNCT,
	RE_TC_PCC_SPACE,
	RE_TC_PCC_UPPER,
	RE_TC_PCC_WORD,
	RE_TC_PCC_XDIGIT,

	/* escaped metacharacters => Ordinary */
	/* RE_TC_ESC_LBRACKET is above PCC tokens */
	RE_TC_ESC_RBRACKET,
	RE_TC_ESC_LBRACE,
	RE_TC_ESC_RBRACE,
	RE_TC_ESC_LPAREN,
	RE_TC_ESC_RPAREN,
	RE_TC_ESC_CARET,
	RE_TC_ESC_DOLLAR,
	RE_TC_ESC_QMARK,
	RE_TC_ESC_PLUS,
	RE_TC_ESC_ASTERISK,
	RE_TC_ESC_PERIOD,
	RE_TC_ESC_BAR,
	RE_TC_ESC_BSLASH,

	/* Multichar tokens */
	RE_TC_PLUS_LAZY,
	RE_TC_QMARK_LAZY,
	RE_TC_ASTERISK_LAZY,

	RE_TC_DIGIT,
	RE_TC_NON_DIGIT,
	RE_TC_WORD_CHAR,
	RE_TC_NON_WORD_CHAR,
	RE_TC_WHITESPACE,
	RE_TC_NON_WHITESPACE,

	RE_TC_BEGIN,
	RE_TC_END,
	RE_TC_BOUND_WORD, /* CTX: RE_CTX_NONE */
	RE_TC_BOUND_NON_WORD,

	RE_TC_BELL,
	RE_TC_BS, /* CTX: RE_CTX_BKT */
	RE_TC_FF,
	RE_TC_NL,
	RE_TC_CR,
	RE_TC_VT,
	RE_TC_TAB,
	RE_TC_HEX,

	/* Single byte tokens */
	RE_TC_LBRACKET,
	RE_TC_RBRACKET,
	RE_TC_LBRACE,
	RE_TC_RBRACE,
	RE_TC_LPAREN,
	RE_TC_RPAREN,
	RE_TC_CARET,
	RE_TC_DOLLAR,
	RE_TC_QMARK,
	RE_TC_PLUS,
	RE_TC_ASTERISK,
	RE_TC_PERIOD,
	RE_TC_BAR,
	RE_TC_BSLASH,
};

/* Start generated code. Generated by: gentokens.py */
/* clang-format off */

static const str RE_PCC_CHARS[] = {
	[RE_TC_PCC_ALNUM] = M_str(
		"0123456789abcde"
		"fghijklmnopqrst"
		"uvwxyzABCDEFGHI"
		"JKLMNOPQRSTUVWX"
		"YZ"
	),
	[RE_TC_PCC_ALPHA] = M_str(
		"abcdefghijklmno"
		"pqrstuvwxyzABCD"
		"EFGHIJKLMNOPQRS"
		"TUVWXYZ"
	),
	[RE_TC_PCC_ASCII] = M_str(
		"\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e"
		"\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d"
		"\x1e\x1f !\"#$%%&\'()*+"
		",-./0123456789:"
		";<=>?@ABCDEFGHI"
		"JKLMNOPQRSTUVWX"
		"YZ[\\]^_`abcdefg"
		"hijklmnopqrstuv"
		"wxyz{|}~\x7f"
	),
	[RE_TC_PCC_BLANK] = M_str(
		" \t"
	),
	[RE_TC_PCC_CNTRL] = M_str(
		"\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e"
		"\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d"
		"\x1e\x7f"
	),
	[RE_TC_PCC_DIGIT] = M_str(
		"0123456789"
	),
	[RE_TC_PCC_GRAPH] = M_str(
		"!\"#$%&\'()*+,-./"
		"0123456789:;<=>"
		"?@ABCDEFGHIJKLM"
		"NOPQRSTUVWXYZ[\\"
		"]^_`abcdefghijk"
		"lmnopqrstuvwxyz"
		"{|}~"
	),
	[RE_TC_PCC_LOWER] = M_str(
		"abcdefghijklmno"
		"pqrstuvwxyz"
	),
	[RE_TC_PCC_PRINT] = M_str(
		" !\"#$%&\'()*+,-."
		"/0123456789:;<="
		">?@ABCDEFGHIJKL"
		"MNOPQRSTUVWXYZ["
		"\\]^_`abcdefghij"
		"klmnopqrstuvwxy"
		"z{|}~"
	),
	[RE_TC_PCC_PUNCT] = M_str(
		"!\"#$%&\'()*+,-./"
		":;<=>?@[\\]^_`{|"
		"}~"
	),
	[RE_TC_PCC_SPACE] = M_str(
		" \t\n\r\f\v"
	),
	[RE_TC_PCC_UPPER] = M_str(
		"ABCDEFGHIJKLMNO"
		"PQRSTUVWXYZ"
	),
	[RE_TC_PCC_WORD] = M_str(
		"0123456789abcde"
		"fghijklmnopqrst"
		"uvwxyzABCDEFGHI"
		"JKLMNOPQRSTUVWX"
		"YZ_"
	),
	[RE_TC_PCC_XDIGIT] = M_str(
		"0123456789ABCDE"
		"Fabcdef"
	),
};

static const token_T RE_TOKENS[] = {
	[RE_TC_CTX_B] = { .chars = M_str("\\b"), .type = RE_TC_CTX_B },
	[RE_TC_PCC_ALNUM] = { .chars = M_str("[:alnum:]"), .type = RE_TC_PCC_ALNUM },
	[RE_TC_PCC_ALPHA] = { .chars = M_str("[:alpha:]"), .type = RE_TC_PCC_ALPHA },
	[RE_TC_PCC_ASCII] = { .chars = M_str("[:ascii:]"), .type = RE_TC_PCC_ASCII },
	[RE_TC_PCC_BLANK] = { .chars = M_str("[:blank:]"), .type = RE_TC_PCC_BLANK },
	[RE_TC_PCC_CNTRL] = { .chars = M_str("[:cntrl:]"), .type = RE_TC_PCC_CNTRL },
	[RE_TC_PCC_DIGIT] = { .chars = M_str("[:digit:]"), .type = RE_TC_PCC_DIGIT },
	[RE_TC_PCC_GRAPH] = { .chars = M_str("[:graph:]"), .type = RE_TC_PCC_GRAPH },
	[RE_TC_PCC_LOWER] = { .chars = M_str("[:lower:]"), .type = RE_TC_PCC_LOWER },
	[RE_TC_PCC_PRINT] = { .chars = M_str("[:print:]"), .type = RE_TC_PCC_PRINT },
	[RE_TC_PCC_PUNCT] = { .chars = M_str("[:punct:]"), .type = RE_TC_PCC_PUNCT },
	[RE_TC_PCC_SPACE] = { .chars = M_str("[:space:]"), .type = RE_TC_PCC_SPACE },
	[RE_TC_PCC_UPPER] = { .chars = M_str("[:upper:],"), .type = RE_TC_PCC_UPPER },
	[RE_TC_PCC_WORD] = { .chars = M_str("[:word:]"), .type = RE_TC_PCC_WORD },
	[RE_TC_PCC_XDIGIT] = { .chars = M_str("[:xdigit:]"), .type = RE_TC_PCC_XDIGIT },
	[RE_TC_PLUS_LAZY] = { .chars = M_str("+?"), .type = RE_TC_PLUS_LAZY },
	[RE_TC_QMARK_LAZY] = { .chars = M_str("??"), .type = RE_TC_QMARK_LAZY },
	[RE_TC_ASTERISK_LAZY] = { .chars = M_str("*?"), .type = RE_TC_ASTERISK_LAZY },
	[RE_TC_ESC_LBRACKET] = { .chars = M_str("\\["), .type = RE_TT_ORD, .value = '[' },
	[RE_TC_ESC_RBRACKET] = { .chars = M_str("\\]"), .type = RE_TT_ORD, .value = ']' },
	[RE_TC_ESC_LBRACE] = { .chars = M_str("\\{"), .type = RE_TT_ORD, .value = '{' },
	[RE_TC_ESC_RBRACE] = { .chars = M_str("\\}"), .type = RE_TT_ORD, .value = '}' },
	[RE_TC_ESC_LPAREN] = { .chars = M_str("\\("), .type = RE_TT_ORD, .value = '(' },
	[RE_TC_ESC_RPAREN] = { .chars = M_str("\\)"), .type = RE_TT_ORD, .value = ')' },
	[RE_TC_ESC_CARET] = { .chars = M_str("\\^"), .type = RE_TT_ORD, .value = '^' },
	[RE_TC_ESC_DOLLAR] = { .chars = M_str("\\$"), .type = RE_TT_ORD, .value = '$' },
	[RE_TC_ESC_QMARK] = { .chars = M_str("\\?"), .type = RE_TT_ORD, .value = '?' },
	[RE_TC_ESC_PLUS] = { .chars = M_str("\\+"), .type = RE_TT_ORD, .value = '+' },
	[RE_TC_ESC_ASTERISK] = { .chars = M_str("\\*"), .type = RE_TT_ORD, .value = '*' },
	[RE_TC_ESC_PERIOD] = { .chars = M_str("\\."), .type = RE_TT_ORD, .value = '.' },
	[RE_TC_ESC_BAR] = { .chars = M_str("\\|"), .type = RE_TT_ORD, .value = '|' },
	[RE_TC_ESC_BSLASH] = { .chars = M_str("\\\\"), .type = RE_TT_ORD, .value = '\\' },
	[RE_TC_DIGIT] = { .chars = M_str("\\d"), .type = RE_TC_DIGIT },
	[RE_TC_NON_DIGIT] = { .chars = M_str("\\D"), .type = RE_TC_NON_DIGIT },
	[RE_TC_WORD_CHAR] = { .chars = M_str("\\w"), .type = RE_TC_WORD_CHAR },
	[RE_TC_NON_WORD_CHAR] = { .chars = M_str("\\W"), .type = RE_TC_NON_WORD_CHAR },
	[RE_TC_WHITESPACE] = { .chars = M_str("\\s"), .type = RE_TC_WHITESPACE },
	[RE_TC_NON_WHITESPACE] = { .chars = M_str("\\S"), .type = RE_TC_NON_WHITESPACE },
	[RE_TC_BEGIN] = { .chars = M_str("\\A"), .type = RE_TC_BEGIN },
	[RE_TC_END] = { .chars = M_str("\\Z"), .type = RE_TC_END },
	[RE_TC_BOUND_WORD] = { .chars = M_str("\\b"), .type = RE_TC_BOUND_WORD },
	[RE_TC_BOUND_NON_WORD] = { .chars = M_str("\\B"), .type = RE_TC_BOUND_NON_WORD },
	[RE_TC_BELL] = { .chars = M_str("\\a"), .type = RE_TC_BELL, .value = '\a' },
	[RE_TC_BS] = { .chars = M_str("\\b"), .type = RE_TC_BS, .value = '\b' },
	[RE_TC_FF] = { .chars = M_str("\\f"), .type = RE_TC_FF, .value = '\f' },
	[RE_TC_NL] = { .chars = M_str("\\n"), .type = RE_TC_NL, .value = '\n' },
	[RE_TC_CR] = { .chars = M_str("\\r"), .type = RE_TC_CR, .value = '\r' },
	[RE_TC_VT] = { .chars = M_str("\\v"), .type = RE_TC_VT, .value = '\v' },
	[RE_TC_TAB] = { .chars = M_str("\\t"), .type = RE_TC_TAB, .value = '\t' },
	[RE_TC_HEX] = { .chars = M_str("\\x"), .type = RE_TC_HEX },
	[RE_TC_LBRACKET] = { .chars = M_str("["), .type = RE_TC_LBRACKET, .value = '[' },
	[RE_TC_RBRACKET] = { .chars = M_str("]"), .type = RE_TC_RBRACKET, .value = ']' },
	[RE_TC_LBRACE] = { .chars = M_str("{"), .type = RE_TC_LBRACE, .value = '{' },
	[RE_TC_RBRACE] = { .chars = M_str("}"), .type = RE_TC_RBRACE, .value = '}' },
	[RE_TC_LPAREN] = { .chars = M_str("("), .type = RE_TC_LPAREN, .value = '(' },
	[RE_TC_RPAREN] = { .chars = M_str(")"), .type = RE_TC_RPAREN, .value = ')' },
	[RE_TC_CARET] = { .chars = M_str("^"), .type = RE_TC_CARET, .value = '^' },
	[RE_TC_DOLLAR] = { .chars = M_str("$"), .type = RE_TC_DOLLAR, .value = '$' },
	[RE_TC_QMARK] = { .chars = M_str("?"), .type = RE_TC_QMARK, .value = '?' },
	[RE_TC_PLUS] = { .chars = M_str("+"), .type = RE_TC_PLUS, .value = '+' },
	[RE_TC_ASTERISK] = { .chars = M_str("*"), .type = RE_TC_ASTERISK, .value = '*' },
	[RE_TC_PERIOD] = { .chars = M_str("."), .type = RE_TC_PERIOD, .value = '.' },
	[RE_TC_BAR] = { .chars = M_str("|"), .type = RE_TC_BAR, .value = '|' },
	[RE_TC_BSLASH] = { .chars = M_str("\\"), .type = RE_TC_BSLASH, .value = '\\' },
	{ .chars = M_str("\x00"), .type = RE_TT_ORD, .value = '\x00' },
};
/* clang-format on */
/* End generated code. Generated by: gentokens.py */

enum re_token_info {
	RE_NTOKENS = (sizeof RE_TOKENS) / (sizeof RE_TOKENS[0]),
	RE_MAX_TOKEN_CHARS = 10, /* That is [:xdigit:] */
};

enum re_extension {
	RE_EXT_ATOMIC,
	RE_EXT_GNAME,
	/* Number of extensions */
	RE_EXT_COUNT
};

/* Extension prefixes must start with a question-mark(?) */
static const str re_ext_prefixes[RE_EXT_COUNT] = {
	[RE_EXT_ATOMIC] = M_str("?>"),
	[RE_EXT_GNAME] = M_str("?P"),
};

#endif
