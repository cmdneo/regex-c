def repr_single(s):
    return "'" + repr('"' + s)[2:]


def repr_double(s):
    return '"' + repr_single(s).replace('"', '\\"')[1:-1] + '"'


chars = {
    "RE_TC_PCC_ALNUM": ("0123456789abcdefghijklmnopqrstuvwxyz"
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    "RE_TC_PCC_ALPHA": ("abcdefghijklmnopqrstuvwxyz"
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    "RE_TC_PCC_ASCII": ("\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r"
                        "\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a"
                        "\x1b\x1c\x1d\x1e\x1f " "!\"#$%%&\'()*+,-./"
                        "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
                        "abcdefghijklmnopqrstuvwxyz{|}~\x7f"),
    "RE_TC_PCC_BLANK": (" \t"),
    "RE_TC_PCC_CNTRL": ("\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c"
                        "\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19"
                        "\x1a\x1b\x1c\x1d\x1e\x7f"),
    "RE_TC_PCC_DIGIT": ("0123456789"),
    "RE_TC_PCC_GRAPH": ("!\"#$%&\'()*+,-./0123456789:;<=>?@"
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
                        "abcdefghijklmnopqrstuvwxyz{|}~"),
    "RE_TC_PCC_LOWER": ("abcdefghijklmnopqrstuvwxyz"),
    "RE_TC_PCC_PRINT": (" !\"#$%&\'()*+,-./0123456789:;<=>?@"
                        "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`"
                        "abcdefghijklmnopqrstuvwxyz{|}~"),
    "RE_TC_PCC_PUNCT": ("!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~"),
    "RE_TC_PCC_SPACE": (" \t\n\r\f\v"),
    "RE_TC_PCC_UPPER": ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    "RE_TC_PCC_WORD": ("0123456789abcdefghijklmnopqrstuvwxyz"
                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ_"),
    "RE_TC_PCC_XDIGIT": ("0123456789ABCDEFabcdef"),
}

# ##### Tokens #####

meta = "[]{}()^$.*?+|\\"

toks = R"""
RE_TC_CTX_B = \b

RE_TC_ESC_LBRACKET = \[ = [ = ORD

RE_TC_PCC_ALNUM = [:alnum:]
RE_TC_PCC_ALPHA = [:alpha:]
RE_TC_PCC_ASCII = [:ascii:]
RE_TC_PCC_BLANK = [:blank:]
RE_TC_PCC_CNTRL = [:cntrl:]
RE_TC_PCC_DIGIT = [:digit:]
RE_TC_PCC_GRAPH = [:graph:]
RE_TC_PCC_LOWER = [:lower:]
RE_TC_PCC_PRINT = [:print:]
RE_TC_PCC_PUNCT = [:punct:]
RE_TC_PCC_SPACE = [:space:]
RE_TC_PCC_UPPER = [:upper:],
RE_TC_PCC_WORD = [:word:]
RE_TC_PCC_XDIGIT = [:xdigit:]

RE_TC_ESC_RBRACKET = \] = ] = ORD
RE_TC_ESC_LBRACE = \{ = { = ORD
RE_TC_ESC_RBRACE = \} = } = ORD
RE_TC_ESC_LPAREN = \( = ( = ORD
RE_TC_ESC_RPAREN = \) = ) = ORD
RE_TC_ESC_CARET = \^ = ^ = ORD
RE_TC_ESC_DOLLAR = \$ = $ = ORD
RE_TC_ESC_QMARK = \? = ? = ORD
RE_TC_ESC_PLUS = \+ = + = ORD
RE_TC_ESC_ASTERISK = \* = * = ORD
RE_TC_ESC_PERIOD = \. = . = ORD
RE_TC_ESC_BAR = \| = | = ORD
RE_TC_ESC_BSLASH = \\ = \\ = ORD

RE_TC_PLUS_LAZY = +?
RE_TC_QMARK_LAZY = ??
RE_TC_ASTERISK_LAZY = *?


RE_TC_DIGIT = \d
RE_TC_NON_DIGIT = \D
RE_TC_WORD_CHAR = \w
RE_TC_NON_WORD_CHAR = \W
RE_TC_WHITESPACE = \s
RE_TC_NON_WHITESPACE = \S
RE_TC_BEGIN = \A
RE_TC_END = \Z
RE_TC_BOUND_WORD = \b
RE_TC_BOUND_NON_WORD = \B

RE_TC_BELL = \a = \a
RE_TC_BS = \b = \b
RE_TC_FF = \f = \f
RE_TC_NL = \n = \n
RE_TC_CR = \r = \r
RE_TC_VT = \v = \v
RE_TC_TAB = \t = \t
RE_TC_HEX = \x

RE_TC_LBRACKET = [= [
RE_TC_RBRACKET = ]= ]
RE_TC_LBRACE = {= {
RE_TC_RBRACE = }= }
RE_TC_LPAREN = (= (
RE_TC_RPAREN = )= )
RE_TC_CARET = ^= ^
RE_TC_DOLLAR = $= $
RE_TC_QMARK = ?= ?
RE_TC_PLUS = += +
RE_TC_ASTERISK = *= *
RE_TC_PERIOD = .= .
RE_TC_BAR = |= |
RE_TC_BSLASH = \= \\

""".split("\n")


# ###########################################################
# ################# START CODE GENERATION ###################
# ###########################################################

# POSIX char class data array generation

print("""/* Start generated code. Generated by: gentokens.py */
/* clang-format off */

static const str RE_PCC_CHARS[] = {""")

for k, v in chars.items():
    print(f"\t[{k}] = M_str(")

    # 15 MAX chars on each line
    lines = [v[x:x + 15] for x in range(0, len(v), 15)]
    for line in lines:
        print("\t\t" + repr_double(line))
    print("\t),")

print("};\n")

# Tokens generation

print("static const token_T RE_TOKENS[] = {")

for tok in toks:
    if tok.strip() == "":
        continue
    fields = tok.split("=")
    tt, val = fields[0].strip(), fields[1].strip()

    if len(fields) == 4 and fields[3].strip() == "ORD":
        print(f"\t[{tt}] = {{ .chars = M_str({repr_double(val)}), "
              f".type = RE_TT_ORD, .value = '{(fields[2].strip())}' }},"
              )

    elif len(fields) == 3:
        print(
            f"\t[{tt}] = {{ .chars = M_str({repr_double(val)}), .type = {tt}, "
            f".value = '{(fields[2].strip())}' }},")

    else:
        print(
            f"\t[{tt}] = {{ .chars = M_str({repr_double(val)}), "
            f".type = {tt} }},"
        )

print("};")

print("""/* clang-format on */
/* End generated code. Generated by: gentokens.py */""")
